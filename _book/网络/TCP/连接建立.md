# 连接建立

### 三次握手

[![1614160878-fiflkq-image.png](https://github.com/muluoleiguo/interview/raw/master/images/WEBRESOURCE7efe0882d1773eea16167448bcb25428.png)](https://github.com/muluoleiguo/interview/blob/master/images/WEBRESOURCE7efe0882d1773eea16167448bcb25428.png)

三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段：

1. 第一次握手：首先客户端向服务器发送一个 SYN 包，并等待服务器确认，其中：

- Client将标志位SYN置为1，表示请求建立连接；
- 序号为 Seq = x（x 随机产生,一般为 1）；
- 随后客户端进入 SYN-SENT 阶段，等待Server确认。

2. 第二次握手：服务器接收到客户端发来的 标志位SYN=1的 包后，对该包进行确认后结束 LISTEN 阶段，并返回一段 TCP 报文，其中：

- 标志位为 SYN 和 ACK 都置为1，表示确认客户端的报文 Seq 序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接；
- 序号为 Seq = y(随机产生一个值y)；
- 确认号为 Ack = x + 1，表示收到客户端的序号 Seq 并将其值加 1 作为自己确认号 Ack 的值，随后服务器端进入 SYN-RECV 阶段,此时操作系统为该TCP连接分配TCP缓存和变量。

3. 第三次握手:客户端接收到发送的 SYN + ACK 包后，检查Ack是否为x+1，ACK是否为1,明确了从客户端到服务器的数据传输是正常的，从而结束 SYN-SENT 阶段。并返回最后一段报文,并且此时操作系统为该TCP连接分配TCP缓存和变量。其中：

- 标志位为 ACK=1，表示确认收到服务器端同意连接的信号
- 序号为 Seq = x + 1，表示收到服务器端的确认号 Ack，并将其值作为自己的序号值
- 确认号为 Ack= y + 1，表示收到服务器端序号 Seq，并将其值加 1 作为自己的确认号 Ack 的值
- 随后客户端进入 ESTABLISHED

当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束 SYN-RECV 阶段，进入 ESTABLISHED 阶段，从而完成三次握手。随后Client和Server就可以开始传输数据  


### 为什么是三次握手？两次不可以么

三次握手是为了防止，客户端的请求报文在网络滞留，客户端超时重传了请求报文，服务端建立连接，传输数据，释放连接之后，服务器又收到了客户端滞留的请求报文，建立连接一直等待客户端发送数据。

服务器对客户端的请求进行回应(第二次握手)后，就会理所当然的认为连接已建立，而如果客户端并没有收到服务器的回应呢？此时，客户端仍认为连接未建立，服务器会对已建立的连接保存必要的资源，如果大量的这种情况，服务器会崩溃  


### 为什么不是四次

不用四次： 本来握手应该和挥手一样都是需要确认两个方向都能联通的，本来模型应该是： 1.客户端发送syn0给服务器 2.服务器收到syn0，回复ack(syn0+1) 3.服务器发送syn1 4.客户端收到syn1，回复ack(syn1+1) 因为tcp是全双工的，上边的四部确认了数据在两个方向上都是可以正确到达的，但是2，3步没有没有上下的联系，可以将其合并，加快握手效率，所有就变成了3步握手  


### 第 2 次握手传回了 ACK，为什么还要传回 SYN

ACK 是为了告诉客户端发来的数据已经接收无误，而传回 SYN 是为了告诉客户端，服务端收到的消息确实是客户端发送的消息





### 如果每次握手对方都没有接受到信息怎么办

- 若第一次握手服务器未接收到客户端请求建立连接的数据包时，服务器不会进行任何相应的动作，而客户端由于在一段时间内没有收到服务器发来的确认报文， 因此会等待一段时间后重新发送 SYN 同步报文，若仍然没有回应，则重复上述过程直到发送次数超过最大重传次数限制后，建立连接的系统调用会返回 -1。
- 若第二次握手客户端未接收到服务器回应的 ACK 报文时，客户端会采取第一次握手失败时的动作，这里不再重复，而服务器端此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文。
- 若第三次握手服务器未接收到客户端发送过来的 ACK 报文，同样会采取类似于客户端的超时重传机制，若重传次数超过限制后仍然没有回应，则 accept() 系统调用返回 -1，服务器端连接建立失败。但此时客户端认为自己已经连接成功了，因此开始向服务器端发送数据，但是服务器端的 accept() 系统调用已返回，此时没有在监听状态。因此服务器端接收到来自客户端发送来的数据时会发送 RST 报文给 客户端，消除客户端单方面建立连接的状态。

