# 缓存问题

### 缓存雪崩

缓存雪崩指的是缓存同一时间大面积失效，所以后面的请求都会落到数据库上，造成数据库短时间承受大量请求而崩掉。可以简单地理解为：由于原有缓存失效，新缓存未到期间（设置缓存时采用了相同的过期时间，在同一时刻出线大面积的缓存过期）所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成了巨大压力，严重的会造成数据库宕机，从而形成一系列的连锁反应，造成整个系统崩溃  


**解决办法**

事前：尽量保证整个Redis集群的高可用性，发现机器宕机尽快补上，选择合适的内存淘汰策略
事中：本地ehcache缓存+hystrix限流&降级，避免mysql崩掉，通过加锁或者队列来控制数据库读写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待
事后：利用Redis持久化机制保存的数据尽快恢复缓存  

### 缓存穿透

一般黑客故意去请求缓存中不存在的数据，导致所有的请求都落在数据库上，造成数据库短时间内承受大量请求而崩掉

简单来说：是指查询一个一定不存在的数据，由于缓存不命中，接着查询数据库也无法查询出结果，因此不会写入缓存中，这将导致每个查询都会去请求数据库，造成缓存穿透  


**解决办法**：

* **布隆过滤器**
  这是最常见的一种解决办法了，它是将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力
* **缓存空对象**
  当存储层不命中后，即使返回空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；如果一个查询返回的数据为空，我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不会超过五分钟。

但是这个方法会存在两个问题

* 如果空指能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键
* 即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性业务会有影响

我们可以从适用场景和维护成本两方面对这两汇总方法进行一个简单比较

* **适用场景**：缓存空对象适用于数据命中不高，数据频繁变化且实时性高。布隆过滤器适合数据命中不高，数据相对固定且实时性低
* **维护成本**：缓存空对象的方法适合代码维护简单，需要较多的缓存空间，数据会出现不一致现象。布隆过滤器适合代码维护较复杂，缓存空间要少一些   

### 缓存预热

除了缓存服务器自带的缓存失效策略意外，我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：定期删除和惰性删除  


### 缓存击穿
是指一个key非常热点，不停的扛着大并发，大并发集中对一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求到数据库，就像在一个屏障上凿了一个洞

比如常见的电商项目中，某些货物成了”爆款“，可以对一些主打商品的缓存直接设置为永不过期，即使某些商品自己发酵成了爆款，也是直接设为永不过期就好了  


### 缓存降级

当访问量剧增，服务出现问题或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使有损服务，系统可以根据一些关键数据自行降级，也可以配置开关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的。以参考日志级别设置预案

服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法是，Redis出现问题，不去数据库查询，而是直接返回默认值给客户

