# 服务器高可用性

### 概念

* 系统在面对各种**异常**时可以提供**正常服务**的能力
* 正常服务业务和生存系统业务
* 可用性 ！= 易用性   
  

### 错误隔离原理

server主循环：

```c++
server_proc(){
     while(1){
          while(have_request(request))
                handle_request(request);
          while(have_timer(timer))
                handle_timer(timer);
     }
}
```

服务器的两类驱动源：**请求**和**定时器**

对逻辑错误的隔离可以转化为对引起的错误的请求和定时器的隔离，比如要释放100号技能，出现了问题，那么就让他只能释放别的技能



**错误隔离系统设计**

* **逻辑错误**：基于动态开关框架对模块添加的动态开关，可随时关闭开启相关逻辑
* **数据错误**：由于游戏服务器大多将对象数据保存于共享内存中，可以将导致异常的驱动源实例或者内存对象通过接口进行隔离  





### 引起进程宕机的原因

* 代码bug:空指针/越界
* 系统限制：堆栈溢出/内存溢出
* 人为因素：运维误操作/死循环强杀  
  



### 使用共享内存维护状态

利用Linux共享内存，Linux系统里面有一个叫SHMGET的系统调用，他会在kernel里面分配一块共享内存，然后通过SHMAT这个接口可以把这块内存映射到进程的内存空间里来，有两个进程的话可以同时采取这块内存

![1637744483(1)](C:\Users\hp\Desktop\1637744483(1).png)

小技巧：如果不调用shmdt,进程退出后shm仍然保存在内核中。进程重新启动后重新shmat这块内存的技术我们称之为resume

服务器把需要保存的这些状态数据全都放在这个SHARED MOMERY里，挂了以后重新启动ATTACH就可以



**共享内存数据的组织形式**

* 角色信息
* 队伍信息
* 帮盟信息
* 活动信息

**数据特点**

* 大小固定
* 数量固定  

**内存池or对象池?**

适用对象池管理数据，因为对象池有固定数据大小的特性  






### 系统容灾

如果resume不起来就要系统容灾

**单点（center）：**

* 系统中只存在唯一实例的节点
* 单点是获取/维护某些值的权威方
* 关键路径单点/非关键路径单点

**单点适用场景**

* 分区分服的游戏架构，单服承载人数较少，维护影响小
* 对一致性要求不高的游戏类型，比如对局类游戏，允许局内回滚或者数据丢失

**针对单点问题的应对策略**

**硬件策略**：

* 可用性层级分类

  比如center是一类（不可或缺），chat,mail是一类（暂时关闭不会影响太多游戏内容），网关是一类（少几台也无所谓）

* 同级部署

  把同一类部署在同一个物理机上

* 冗余部署

  * 增加链路
  * 增加备份节点

  适用于无状态或者弱状态游戏（就是进程虽然会保留上下文数据，但是重启以后数据没了就是没了，不重要，像棋牌类，当局游戏没了就没了）

**软件策略：**

* 服务失效（隔离）

* 主从/冷热备

   冷备，就是当前的master server挂了，可以切到slave server上去,但是他们没有上下文联系

   热备就是master server和slave server中间有一个链路，同步数据，他们的实时状态是一致的，适合强状态的服务  


**当有两台server的时候怎么确定什么是主，什么是从？**

业界用得比较多的是zookeeper这些，适用于大规模集群场景的，他是有一个选取算法的，没有一个单点的概念，它通过集群选取的算法来确定唯一的LEADER  


### 主从数据同步

* 同时发送：客户端请求同时发给主从，主从执行相同的逻辑，产生相同的数据变更

  缺点：两边数据一旦不一致以后，会越差越远，没有一个容错机制

* 版本号机制：只在master上做逻辑处理，然后把版本号和处理后的数据发给slave，使用数据版本号标示数据变更，高版本号无条件覆盖低版本号

  优点：1.同步量小

  ​            2.时效性较高

  ​            3.最终一致性

  缺点：不支持单独维护，slave坏掉了，再起来就不能当slave了，因为它前面变更的数据都丢失了，同步的话要从头开始同步

* 定时快照机制：

  master定时产生快照数据，同步给slave,slave无条件刷新快照，普通操作仍然同步给slave  
  



### 数据容灾

|          | 重要性 | 数据量 | 策略                        |
| :------- | ------ | ------ | --------------------------- |
| 游戏数据 | 极高   | 稳定   | 在线热备<br />定期冷备+流水 |
| 流水日志 | 高     | 极大   | 定时冷备<br />定期清理      |
| 进程日志 | 高     | 极大   | 定时清理                    |
| 系统状态 | 中     | 极大   | 定时清理                    |

**在线热备**

保证数据在线的可用性，在游戏过程中，不能说DB突然忙了，数据拉不到了。所以一般会在DB这一层做一个冗余的备份，如果使用Mysql的话，同时会开一个DB一个DR,然后由DBPOXY进程来负责它透明的切换，如果DB挂掉DBPROXY可以马上访问到DR,DB，DR一般放到两台物理机上  




**定期冷备+流水**

每天整个DB，我们会全量的DUMP一份数据，这个DUMP一般选择在凌晨四五点的时候进行，因为这时候玩家最少，DUMP对机器有一定的性能要求。DUMP可以将DB恢复到指定时刻，较多用在数据丢失或者损坏的场合，恢复的时间成本较高

