# 问题的定位分析

### 基本过程

查找、定位和解决问题就是软件调试。软件调试从一开始实际上就包含了定位错误和去除错误这两个基本步骤。进一步讲，一个完整的软件调试过程是一个循环过程，它由以下几个步骤组成。

* **重现故障**
  通常是在用于调试的系统上重复导致故障的步骤，使要解决的问题出现在被调试的系统中。

* **定位根源**
  即综合利用各种调试工具，使用各种调试手段寻找导致软件故障的根源（rootcause）。通常测试人员报告和描述的是软件故障所表现出的外在症状，比如界面或执行结果中所表现出的异常；或者是与软件需求（requirement）和功能规约（function specification）不符的地方,即所谓的软件缺欠(defect)。而这些表面的缺欠总是由于一个或多个内在因素导致的，这些内因要么是代码的行为错误，要么是不行为错误（该做而未做）。定位根源就是要找到导致外在缺欠的内因。

* **探索和实现解决方案**
  即根据寻找到的故障根源、资源情况、紧迫程度等设计和实现解决方案。

* **验证方案**
  在目标环境中测试方案的有效性，又称回归（regress）测试。如果问题已经解决，那么就可以关闭问题。如果没有解决，则回到第三步调整和修改解决方案。    

  

### 基本特征

* **难度大**

  软件调试时一项复杂度高、难度大的任务。一下是导致这种复杂性的几个主要因素。

  * 如果把查找和定位问题看作是一种特别的搜索问题，那么它通常是个很复杂的搜索问题。首先，被搜索的目标空间是软件问题发生的系统，从所包含的信息量来看，这个空间通常是很庞大的，因为一个典型的计算机系统中包含着几十个硬件部件、数千个软件模块，每个模块又包含着以KB或MB为单位的大量指令（代码）。另一方面，这个搜索问题并没有明确的目标和关键字，通常只知道不是非常明确的外在症状，必须通过大量的分析，才能逐步接近真正的内在原因。
  * 为了查找定位问题的根源，很多时候必须深入到被调试模块或系统的底层，研究内部的数据和代码。与顶层不同，底层的数据大多是以原始状态存在的，理解和分析的难度比顶层要大。举例来说，对于顶层看到的文字信息，在底层看到的可能只是这些文字的某种编码（ANSI或UNICODE等）。对于代码而言，底层意味着低级语言或汇编语言，甚至机器码，因为当无法进行源代码级的调试时，我们不得不进行汇编一级的跟踪和分析。对于通信有关的问题，底层意味着需要观察原始的通信数据包和检查包的各个部分。另外，很多底层的数据和行为是没有文档的，不得不做大量的跟踪和分析才能摸索出一些线索和规律。从API的角度来看，底层意味着不仅要理解API的原型和使用方法，有时还必须知道它内部是如何实现的，执行了哪些操作。
  * 因为要在一个较大的问题域内定位错误，所以要求调试者必须有丰富的知识，熟悉问题域内的各个软硬件模块，以及它们之间的协作方式。从纵向来看，要理解系统从最上层到最下层的各个层次。从横向来看，要理解每个层次内的各个模块。对于每一个模块，不仅要知道其概况。有时还必须深刻理解其细节。举例来说，对于那些应用程序、操作系统和硬件都要有比较深刻的理解。
  * 每个软件调试任务都有很多特殊性，或者说很难找到两个调试任务是一样的。这意味着，当执行一个软件调试任务时，很难找到可以模仿或者借鉴的先例，几乎每一步都必须靠自己的探索来完成。而编写代码和其他软件活动经常有示例代码或者模板可以参考套用。
  * 软件的大型化、层次的增多、多核和多处理器系统的普及都在增加软件调试的难度。

* 时间不确定
  就像侦破一个案件所需的时间很难确定一样，对于一个软件错误，到底需要多久才能定位到它的根源并解决这个问题是一个很难回答的问题。这是因为软件调试问题的范围比较大，调试过程中包含的随机性和不确定性很多，调试人员对问题及相关模块和系统的熟悉程度、对调试技术的熟练程度也会加入很多不确定性。

  调试任务的难以预测性经常给软件工程带来重大的麻烦，其中最常见的便是导致项目延期。事实上，很多软件项目的延期是与无法定位和解决问题有关。

  在现实中，很多软件难题经常成为整个项目组的瓶颈，是项目团队中所有人关注的焦点，包括市场部门和一些高级管理者。这时，对于接受调试任务的工程师来说，除了要面对技术上的难题外，还要承受很多其他方面的压力。这种压力有时会加快问题的解决有时则会降低效率。

*  **广泛的关联性**
  很多调试机制是操作系统、中央处理器和调试器相互协作的复杂过程，比如Windows本地调试中的软件断点功能通常是依赖于CPU的断点指令的，CPU执行到断点指令时中断下来，并以异常的方式报告给操作系统，操作系统再将这个事件发给调试器。

  另外，软件调试和软件编译有着密切的关系。软件的调试版本包含了很多用来辅助软件调试信息，具有更好的可调试性。调试信息中很重要的一个部分便是调试符号，它是进行源代码级调试所必须的。

综上所述，软件调试与计算机系统的硬件核心（CPU）和软件核心（操作系统）都有着很紧密的耦合关系，与软件生产的最主要机器编译器也息息相关。因此，可以说软件调试具有广泛的关联性，有时也被称为系统性。  


### 调试手段

* **断点**
  断点(breakpoint)是使用调试器进行调试时的最常用调试技术之一。其基本思想是在某一个位置设置一个“陷阱”，当CPU执行到这个位置时便会停止执行被调试的程序，中断到调试器（break into debugger）中，让调试者进行分析和调试。调试者分析结束之后，可以让被调试程序恢复执行。

* **单步执行**
  单步执行（step by step）是最早的调试方法之一。简单来说，就是让应用程序按照某一步骤单位一步一步执行。

  单步执行可以跟踪程序执行的每一个步骤，观察代码的执行路线和数据的变化过程，是深入诊断软件动态特征的一种有效方法。但是随着软件向大型化方向的发展，从头到尾跟踪执行一个软件乃至一个模块，一般都不再可行了。一般的做法是先使用断点功能将程序中断到感兴趣的位置，然后再单步执行关键的代码。

* **输出调试信息**
  打印和输出调试信息（debug output/print）是一种简单而又“古老”的软件调试方式。其基本思想就是在程序中编写专门用于输出调试信息的语句，将程序运行的位置、状态和变量取值等信息以文本的形式输出到某一个可以观察到的地方，可以是控制台、窗口、文件、或者调试器。这种方法的优点是简单方便、不依赖于调试器和复杂的工具。因此至今任在很多场合广泛使用。

  这种简单的方式也有一些明显的缺点，比如需要在被调试程序中加入代码，如果被调试程序的某个位置没有打印语句，那么便无法观察到那里的信息，如果要增加打印语句，那么需要重新编译和更新程序。另外，这种方法容易影响程序的执行效率，打印出的文字所包含的信息有限，容易泄露程序的技术细节，通常不可以动态开启、信息不是结构化的、难以分析和整理等。

  利用这种方法输出的调试信息具有实时性的优点，但是同时也有容易丢失和被覆盖的缺点，不适用于长期保存和事后分析。

* **日志**
  与输出调试信息类似，写日志（log）是另一种被调试程序自发的辅助调试手段。其基本思想是在编写程序时加入特定的代码将程序运行的状态信息写到日志文件或数据库中。

  日志文件通常自动按时间取文件名，每一条记录也有详细的时间信息，因此适合长期保存和事后检查与分析。因此很多需要连续长时间在后台运行的服务器程序都具有日志机制。

* **事件追踪**
  打印调试信息和日志都是以文本形式来输出和记录信息的，因此不适合处理数据量庞大且速度要求高的情况。事件追踪机制（Event Trace）正是针对这一需求而设计的，它使用结构化的二进制形式来记录数据，观察时再根据格式文件将信息格式转化为文本形式，因此适用于监视频繁且复杂的软件过程，比如监视文件访问和网络通信等。

* **转储文件**
  某些情况下，我们希望将发生问题时的系统状态像拍照片一样永久保存下来，发送或带走后再进一步分析和调试，这就是转储文件（Dump File）的基本用途。理想情况下，转储文件是转储时目标程序运行系统的一个快照，包含了当时内存中的所有信息，包括代码和各种数据。但在实际情况下，考虑到转储文件过大时不仅要占用大量的磁盘空间，而且不便于发送和传递，因此转储文件通常分为小、中、打几种规格，最小的通常称为Mini Dump。

* **栈回溯**
  目前主流CPU架构都是使用栈来进行函数调用的，栈上记录了函数的返回地址，因此，通过递归式寻找放在栈上的函数返回地址，便可以追溯出当前线程的函数调用序列，这便是栈回溯（Stack Backtrace）的基本原理。通过栈回溯产生的函数调用信息被称为Calling Stack。

  栈回溯是记录和探索程序执行踪迹的极佳方法，使用这种方法，准确且基本不需要额外的开销。很多追踪和记录机制都是基于这种方法设计的。

  因为从栈上得到的只是函数返回地址（数值），不是函数名称，所以为了便于理解，可以利用调试符号（debug symbol）文件将返回地址翻译成函数名。大多数编译器都支持在编译时生成调试符号。

* **反汇编**
  所谓反汇编（disassemble），就是将目标代码（指令）翻译成汇编代码。因为汇编代码与机器有着简单的对应关系，所以反汇编是了解程序目标代码的一种非常直接而且有效的方式。有时当我们对高级语言的某一条语句的执行结果百思不得其解时，可以看一下它所对应的汇编代码，这时往往可以更快发现问题的症结。

  另外，反汇编的依赖性非常小，根据二进制的可执行文件就可以得到汇编语言表示的程序。这也是反汇编的一大优点。

  调试符号对于反汇编有着积极的意义，反汇编工具可以根据调试符号得到函数名和变量名等信息，这样产生的汇编代码具有更好的可读性。

  大多数调试器提供了反汇编和跟踪汇编代码的能力。一些工具也提供了反汇编功能。

* **观察和修改数据**
  观察被调试程序的数据是了解程序内部状态的一种直接的方法，很多调试器提供了观察和修改数据的功能，包括变量和程序的栈及堆等重要数据结构。在调试符号的支持下，可以按照数据类型来显示结构化的数据。

  寄存器值代表了程序运行的瞬时状态，观察和修改寄存器的值也是一种常见的调试技术。  
  

### 学习调试技术的意义：

首先，软件调试技术是解决复杂软件问题的最强大工具。如果把解决复杂软件问题看作是一场战斗，那么软件调试技术便是一种可以直击要害而且锐不可当的武器。说直击要害是因为利用调试技术可以从问题的正面迎头而上，从问题症结着手，直接深入到问题的中心。而不像很多其他技术那样需要从侧面探索，间接地推测，然后做大量的排查。说锐不可当是因为核心的调试技术大多来源于CPU和操作系统的直接支持，因此具有非常好的健壮性和稳定性，有较高的优先级。

第二，提高调试技术水平有利于提高软件工程师特别是程序员的工作效率，降低工作强度。很多软件工程师都认为调试软件花去了他们大半的时间。因此提高调试软件的技术水平和效率对于提高总的工作效率是非常有意义的。

第三，调试技术是学习其他软硬件技术的一个极好的工具。通过软件调试技术的强大观察能力和断点、栈回溯、跟踪等功能可以快速地了解一个软件和系统的模块、架构和工作流程，因此是学习其他软硬件技术的一个快速而又有效的方法。

另外，相对于其他软件技术，软件调试技术具有更好的稳定性，不会在短时间内被淘汰。因此，可以说软件调试技术是一门一旦掌握，便可以长期受用的技术。
