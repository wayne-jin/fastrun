# const

### 作用

* const修饰变量，以下两种定义形式在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的

  ```c++
  TYPE const ValueName = value;
  const Type ValueName = value;
  ```

* 修饰指针

  * 指向常量的指针（底层const），即无法通过该指针对所指变量进行修改，但指针可以重新指向其他内存区域。因为常量指针可以随时指向其他内存区域，所以该类指针不需要初始化

    ```C++
    const char *p;
    char const *p
    ```

  * 自身是常量的指针（顶层const），可对指针指向的变量进行修改，但无法使该指针指向其他内存区域。此类指针无法转而指向其他内存区域，所以必须初始化

    ```c++
    char *const p = &a
    p = &b //error
    ```

* 修饰引用

  * 指向常量的引用，如果用于形参类型，即避免了拷贝，又避免了函数对值的修改
  * 没有const reference，因为引用只是对对象的别名，引用不是对象，不能用const修饰

* 修饰普通函数

  ```C++
  void function(const int val);//传过来的参数在函数内不可以改变（无意义，因为val本身就是形参）
  void function(const char* val);//参数指针所指常量不可变
  void function(char* const val);//参数指针本身为常量不可变（也无意义，因为char* val也是形参）
  void function(const Class& val);//引用参数在函数内不可被改变
  void function(const TYPE& val);//引用参数在函数内为常量不可变
  ```

  这样的一个const引用传递和最普通的值传递效果是一模一样的，它禁止对引用的对象的一切修改，唯一不同的是按值传递会建立一个类对象的副本，然后传递过去，而它直接传递地址，所以这种传递比值传递更有效。&是为了引用传递，防止值传递的复制数据，const是为了保护数据不被改动，const&防止传值时拷贝构造函数的调用开销

* 修饰成员变量

  * const成员变量只能在类内声明，定义，在构造函数初始化列表中初始化
  * const成员对象只是在某个对象的生命周期内是常量，对整个类而言却是可变的，不同类的const成员变量的值是不同的。因此不能在类的声明中初始化const成员变量，类的对象还没创建，编译器不知道它的值

* 修饰成员函数

  说明该成员函数内不能修改成员变量，除非有mutable修饰，只能访问成员变量，不能调用非常量成员函数。const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论是否const对象还是普通对象都可以调用该函数  
  
  
  
  
  

### C++里是怎么定义常量的？常量存放在内存的什么位置？

常量在C++里的定义就是一个顶层const加上对象类型，常量定义必须初始化

* 对于局部对象，常量存放在栈区

* 对于全局对象，常量存放在全局/静态存储区

* 对于字面值变量，常量存放在常量存储区  
   
  
  



### const和define区别

* 编译阶段
  define是在预处理阶段进行替换的，const是在编译阶段确定其值

* 安全性
  define定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查。const定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误

* 内存占用

  define定义的宏常量，在程序中使用多少次就会有多少替换，内存中有多个备份，占用的是代码段的空间；const定义的常量占用的是静态存储区的空间，程序运行过程中只有一份

* 调试

  define定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；const定义的常量可以进行调试
