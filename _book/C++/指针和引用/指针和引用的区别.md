# 指针和引用的区别

### 指针和引用区别

* 指针有自己的一块空间，而引用就只是一个别名
* 使用sizeof看一个指针的大小是4,而引用则是被引用对象的大小
* 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用
* 作为参数传参时，指针需要被解引用才可以对对象进行操作，而直接引用的修改都会改变引用所指向的对象
* 可以有const指针，但是没有const引用
* 指针在使用过程中可以指向其他对象，但是引用只能是一个对象的引用，不能被改变
* 指针可以有多级指针，而引用只有一级
* 指针和引用使用++有运算符的意义不一样
* 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能会造成内存泄露  
  

### C++中引用与指针只要一个可以么

**为什么有了引用还需要指针呢**  

答：因为为了兼容C语言，必然要支持指针  

**为什么有了指针还需要引用呢**  

答：一开始C++是没有引用的，比如说：this被定义为了指针而不是引用，后来加入引用的原因主要是为了支持运算符重载。假设C++里面没有引用，而只有指针，会有什么样的问题。如果用指针来运算符重载的话，就像

```C++
ClassFun operator+(const ClassFun *,const ClassFun *)
```

使用的时候只能是&a+&b，这和我们通常的写法a+b不太一样，看上去不太习惯。还可以进一步假设，也就是可以写成a+b，让编译器来根据operator+的类型来解释a和b的类型。如果operator+的参数是值，那就解释成值，如果是指针，那就解释称地址。这和现在C++里面把名字解释成值或引用是一个道理。这样做的后果是值和指针不能重载了  




**引用带来的好处**：用指针的使用经常犯的错：

* 操作空指针
* 操作野指针
* 误操作改变了指针的值，而后还以为指针正常  
  

**引用区别于指针的特征是**

* 不存在空引用(保证不操作空指针)
* 必须初始化(保证不是野指针)
* 一个引用永远指向它初始化的那个对象，一旦初始化就不能改变初始化的值(保证指针的值不变)，人为保证变为了编译器来保证，更加安全  
  

**注意事项**
用户自定义的类型最好用引用传参，这样可以避免不必要的构造函数和析构函数的调用，但是像int,long,char一类的内置类型，按值传参会比按引用传参更高效  

### 指针参数传递和引用参数传递的区别

* 指针参数传递的本质是值传递，它所传递的是一个地址值，值传递的过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参的值，从而形成了实参的一个副本，值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值(形参指针变了，实参指针不会变)
* 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参(本体)的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量(根据别名找到主调函数中的本体)。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量
