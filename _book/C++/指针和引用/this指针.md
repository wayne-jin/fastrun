# this指针

### 概念

指向类的当前对象的指针常量

* this指针是一个隐含于每一个非静态成员常量的特殊指针，它指向调用该成员函数的那个对象
* 当对一个对象调用成员函数时，编译程序先将对象的地址赋给this指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用this指针
* 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针
* this指针被隐含的声明为ClassName *const this，这意味着不能给this指针赋值，在ClassName类的const成员函数中，this指针的类型为const ClassName*const,这说明不能对this指针所指向的对象的数据成员进行赋值操作
* this并不是一个常规变量，而是个右值，所以不能取得this的地址(不能&this)
* 在以下场景中，经常需要显式引用this指针
  * 为实现对象的链式调用
  * 为避免对同一对象进行赋值操作
  * 在实现一些数据结构如list时  
    

### this指针什么时候创建

this在成员函数的开始执行前构造，在成员的执行结束后清除

如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面进行处理  
  

### this指针存放在何处？堆，栈，全局变量还是其它

this指针会因编译器不同而有不同的放置位置，可能是栈，也可能时寄存器，甚至是全局变量，在汇编级别里面，一个值只会以三种形式出现：立即数，寄存器值，和内存变量值。不是存放在寄存器就是存放在内存中，他们并不是和高级语言的变量所对应的  
 

### 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？

普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰  


### delete this合法么

合法，但：

* 必须保证this对象是通过new分配的
* 必须保证调用delete this的成员函数是最后一个调用this的成员函数
* 必须保证成员函数的delete this后面没有调用this了
* 必须保证delete this后没人使用了





