# new和malloc

### new和malloc区别

| 特征               | new/delete                             | malloc/free                          |
| ------------------ | -------------------------------------- | ------------------------------------ |
| 分配内存的位置     | 自由存储区                             | 堆                                   |
| 内存分配失败返回值 | 完美类型指针                           | void*                                |
| 内存分配失败安全性 | 默认抛出异常                           | 返回NULL                             |
| 分配内存大小       | 编译器根据类型计算得出                 | 必须显式的指定字节数                 |
| 处理数组           | 有处理数组的new[]版本                  | 需要用户计算数组的大小后进行内存分配 |
| 已分配内存的扩充   | 无法直观的处理                         | 使用realloc简单完成                  |
| 是否相互调用       | 可以，看具体的operator new/delete实现  | 不可以调用new                        |
| 分配内存时内存不足 | 客户能够指定处理函数或者重新制定分配器 | 无法通过用户代码进行处理             |
| 函数重载           | 允许                                   | 不允许                               |
| 构造函数与析构函数 | 调用                                   | 不调用                               |

​    


### **malloc原理，brk系统调用和mmap系统调用的作用分别是什么**
malloc函数用于动态分配内存，为了减少内存碎片和系统调用的开销，malloc采用了内存池的方式，先申请大块的内存作为堆区，然后将堆区区分为多个内存块，以块作为内存管理的基本单位，当用户申请内存时，直接从堆区分配一块合适的空闲块，malloc采用隐式链表结构将堆区分成连续的，大小不一的块，包含已分配块和未分配块，同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块链接起来，每一个空闲块记录了一个连续的，未分配的地址

当进行内存分配时，malloc会通过隐式链表遍历所有空闲块，选择满足要求的的块进行分配，当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并

malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请的内存小于128k时，会使用系统函数调用brk()，通过移动_enddata来实现堆区中的分配；而当申请内存大于128k时会使用系统函数mmap在虚拟地址空间映射区分配

  


### **malloc的底层实现**
brk()函数实现原理：像高地址的方向移动指向数据段的高地址的指针_enddata
mmap内存映射原理：

* 进程启动映射过程，并在虚拟低地址空间中为映射创建虚拟映射内存；
* 调用内核空间的系统调用函数mmap()，实现文件物理地址和进程虚拟地址的一一映射关系
* 进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存(主存)的拷贝
