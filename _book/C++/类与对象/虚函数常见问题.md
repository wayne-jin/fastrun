# 虚函数常见问题

### 构造函数一般不定义为虚函数

- 从存储空间的角度考虑：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，**虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有**），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数
- 从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的
- 从实现上考虑：虚函数的执行依赖于虚函数表。而虚函数表在构造函数中进行初始化工作，即初始化vptr，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行
- 从类型上考虑：构造一个对象的时候，必须知道对象的实际类型，而虚函数行为是在运行期间确定实际类型的。而在构造一个对象时，由于对象还未构造成功。编译器无法知道对象的实际类型，是该类本身，还是该类的一个派生类，或是更深层次的派生类  
  

### 析构函数一般定义成虚函数

析构函数定义成虚函数是**为了防止内存泄漏**，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏  


### 为什么C++默认的析构函数不是虚函数

C ++ 默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数  


### 虚函数效率分析

虚函数的动态绑定特性虽然很好，但存在内存空间和时间开销，每个支持虚函数的类（基类或派生类）都会有一个包含其所有支持的虚函数的虚函数表的指针。**每个类对象都会隐含一个虚函数表指针**（virtual pointer），指向其所属类的虚函数表。当通过基类的指针或引用调用某个虚函数时，系统需要首先定位指针或引用真正对应的对象所隐含的虚函数指针，然后虚函数指针根据虚函数的名称对其所指向的虚函数表进行一个偏移定位，再调用偏移定位处的函数指针对应的虚函数，即动态绑定的解析过程。C++规范只需要编译器能够保证动态绑定的语义，但大多数编译器都采用上述方法实现虚函数

* 每个支持虚函数的类都有一个虚函数表，虚函数表的大小与类拥有的虚函数的多少成正比。一**个程序中，每个类的虚函数表只有一个，与类对象的数量无关**。支持虚函数的类的每个类对象都有一个指向类的虚函数表的虚函数指针，因此程序运行时虚函数指针引起的内存开销与生成的类对象数量成正比
* 支持虚函数的类生成每个对象时，**在构造函数中会调用编译器在构造函数内部插入的初始化代码，来初始化其虚函数指针，使其指向正确的虚函数表**。当通过指针或引用调用虚函数时，会根据虚函数指针找到相应类的虚函数表  
  

### 虚函数与内联

内联函数通常可以提高代码执行速度，很多普通函数会根据情况进行内联化，**但虚函数无法利用内联化的优势**。

因为内联是在编译阶段编译器将调用内联函数的位置用内联函数体替代（内联展开），但**虚函数本质上是运行期行为**。在编译阶段，编译器无法知道某处的虚函数调用在真正执行的时候需要调用哪个具体的实现（即编译阶段无法确定其具体绑定），因此，编译阶段编译器不会对通过指针或引用调用的虚函数进行内联化。如果需要利用虚函数的动态绑定的设计优势，必须放弃内联带来的速度优势  



### 哪些函数不能定义为虚函数？

经检验下面的几个函数都不能定义为虚函数：

* 友元函数，它不是类的成员函数
* 全局函数
* 静态成员函数，它没有this指针
* 构造函数，拷贝构造函数，以及赋值运算符重载（可以但是一般不建议作为虚函数）
