# 进程的基本操作

* **创建**

  fork()。新创建的子进程几乎但不完全与父进程相同。**子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本，包括代码和数据段、堆、共享库以及用户栈**。**子进程还获得与父进程任何打开文件描述符相同的副本**，这就意味着当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的 PID。fork函数是有趣的（也常常令人迷惑）， 因为它只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork 返回子进程的 PID。在子进程中，fork 返回 0。因为子进程的 PID 总是为非零，返回值就提供一个明 确的方法来分辨程序是在父进程还是在子进程中执行

  ```C++
  pid_t fork(void);
  ```

* **回收子进程**

  回收子进程：当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被 保持在一种已终止的状态中，直到被它的父进程回收（reaped）。当父进程回收已终止的子进程 时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个进程可以通过调用 waitpid 函数来等待它的子进程终止或者停止

  ```C++
  pid_t waitpid(pid_t pid, int *statusp, int options);
  ```

* **加载并运行程序**

  execve 函数在当前进程的上下文中加载并运行一个新程序

  ```C++
  int execve(const char *filename, const char *argv[], const char *envp[]);
  ```

* **进程终止**

  ```C++
  void exit(int status);
  ```

  

