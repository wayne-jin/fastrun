# 虚拟内存

### 概念

为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存(VM)。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力：

* 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存
* 它为每个进程提供了一致的地址空间，从而简化了内存管理
* 它保护了每个进程的地址空间不被其他进程破坏  
  

### 为什么要引入虚拟内存

在系统中所有的进程之间是共享CPU和主存这些内存资源的。当进程数量变多时，所需要的内存资源就会相应的增加。可能会导致部分程序没有主存空间可用。此外，由于资源是共享的，那么就有可能导致某个进程不小心写了另一个进程所使用的内存，进而导致程序运行不符合正常逻辑。

虚拟内存提供了三个重要的能力： **缓存，内存管理，内存保护**

* **虚拟内存作为缓存的工具**
  * 虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组
  * 虚拟内存利用DRAM缓存来自通常更大的虚拟地址空间的页面

* **虚拟内存作为内存管理的工具**

  操作系统为每个进程提供了一个独立的页表，也就是独立的虚拟地址空间。多个虚拟页面可以映射到同一个物理页面上。

  * 简化链接

    独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。

    例如：一个给定的 linux 系统上的每个进程都是用类似的内存格式，对于64为地址空间，代码段总是从虚拟地址） 0x400000 开始，数据段，代码段，栈，堆等

  * 简化加载

    虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中.text和.data节加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页VP，把他们标记为无效（未被缓存），将页表条目指向目标文件的起始位置。

    - **加载器从不在磁盘到内存实际复制任何数据，在每个页初次被引用时，虚拟内存系统会按照需要自动的调入数据页。**

  * 简化共享

    独立地址空间为OS提供了一个管理用户进程和操作系统自身之间共享的一致机制。

    - 一般：每个进程有各自私有的代码，数据，堆栈，是不和其他进程共享的，**这样OS创建页表，将虚拟页映射到不连续的物理页面。**
    - 某些情况下，需要进程来共享代码和数据。例如每个进程调用相同的操作系统内核代码，或者C标准库函数。**OS会把不同进程中适当的虚拟页面映射到相同的物理页面。**

  * 简化内存分配

    虚拟内存向用户提供一个简单的分配额外内存的机制。当一个运行在用户进程中的程序要求额外的堆空间时（如 malloc ），OS分配一个适当k大小个连续的虚拟内存页面，并且将他们映射到物理内存中任意位置的k个任意物理页面，**因此操作系统没有必要分配k个连续的物理内存页面，页面可以随机的分散在物理内存中**。

* **虚拟内存作为内存保护的工具**

  不应该允许一个用户进程修改它的只读段，也不允许它修改任何内核代码和数据结构，不允许读写其他进程的私有内存，不允许修改任何与其他进程共享的虚拟页面。每次CPU生成一个地址时， MMU 会读一个 PTE ，通过在 PTE 上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单。

* 虚拟内存很适合在**多道程序设计系统**中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高  
  

### 虚拟内存的代价：

* 虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存
* 虚拟地址到物理地址的转换，增加了指令的执行时间
* 页面的换入换出需要磁盘I/O，这是很耗时的
* 如果一页中只有一部分数据，会浪费内存
