# inline

### 作用

inline 是一个关键字，可以用于定义内联函数。内联函数，像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是直接在调用点处展开，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率  


### 编译器对inline函数的处理步骤

1.将inline函数复制到inline函数的调用点处

2.为所用inline函数中的局部变量分配空间

3.将inline函数的输入参数和返回值映射到调用方法的局部变量中

4.如果inline函数有多个返回点，将其转变为inline函数代码块末尾的的分支（使用GOTO）  

### inline函数的优缺点

**优点:**

* inline定义的内联函数，函数代码被放入符号表中，在使用时进行替换（内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度），效率很高
* 类的内联函数也是函数。编绎器在调用一个内联函数，首先会检查参数问题，保证调用正确，像对待真正函数一样，消除了隐患及局限性。内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会
* inline可以作为类的成员函数。在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能
* 内联函数在运行时可调试，而宏定义不可以

**缺点：**

* 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大（比如函数体内有循环），那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。这种情况编译器可能会自动把它作为非内联函数处理
* inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接
* 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器  
     

### 内联函数一般可以

1.加快程序的执行速度

2.可能减少可执行文件的大小

3.可能增加可执行文件的大小

4.可能降低执行速度    

1和3很好理解，在编译时期内联函数能将代码直接写入其被调用的地方，这样就减少了入栈出栈的时间消耗，但是如果调用内联函数的地方过多，代码量也会随之增加，增加了可执行文件的大小

2为什么正确呢？是因为如果调用普通函数的话编译器可能会产生更多的代码来实现压、出寄存器的代码，对于简单的内联函数会这样。但如果优化器能顺序集成消除大量冗余代码的话，对大函数也同样适用

4呢？如果可执行文件过大，会频繁的出现内存的换入换出操作，会使执行速度下降   



### 虚函数可以是内联函数么

* 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联
* 内联是在编译器建议编译期内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联
* `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生
