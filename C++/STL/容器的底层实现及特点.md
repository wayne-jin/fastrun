# 容器的底层实现及特点

## 顺序容器：

### vector

* 底层数据结构——**数组**
* 特性：
  * 随机访问：O(1)
  * 随机插入与删除：O(n)，中间插入会引起后面数据的拷贝，尾部可快速增删
  * 扩容：二倍扩容机制  
    

### list

* 底层数据结构——**双向链表**
* 特性：
  * 随机访问：O(n)，实际上就是不支持随机访问
  * 随机增删：O(1)
  * 扩容：新增单节点即可  
    

### dequeue

* 底层数据结构：类似一个二维数组的缓冲区，缓冲区指的是后面实际存储数据的地方

  ![img](https://pic3.zhimg.com/v2-04d4caae215a43b4502dbfa049e50a5a_b.jpg)

  左边map中存储每个都指向一块连续的内存空间的指针

  图中的finish为一个deque的迭代器样式，可以通过迭代器得知当前位置在哪、与缓冲区的关系是什么、下一个或者上一个缓冲区是啥

* 特性：

  * 随机访问：两次解引用，O(1)
  * 随机增删：O(n)
  * 扩容：和vector一样，扩容时增加节点  
    

## 关联容器：

### set&multiset &map&multimap

* 底层数据结构实现——**红黑树**
* 特性
  * 时间复杂度O(logn)，按键值排序
  * 红黑树的特性：
    * 每个节点非黑即红
    * 根结点为黑
    * 叶节点为黑
    * 一个红节点的子节点都为黑
    * 任何节点到达叶节点的nil节点，都经过相同数量的黑节点  
      

## 无序关联容器：

### **unordered_map&unordered_multimap&unordered_set&unordered_mutiset**



* 底层数据结构实现——**哈希表**

* 特性

  插入，删除，查找时间复杂度平均o(1)，最坏O(n)  
  

## 容器适配器

在容器的接口上进行封装和改写实现

### stack

* 底层容器——**deque**
* 特性：
  * 先进后出
  * 使用top()来访问顶端元素  
    

### queue

* 底层容器——**deque**
* 特性：
  * 先进先出
  * 使用front()访问顶端元素  
    

### priority_queue

* 底层容器——vecotr实现的heap

* 特性

  优先队列



### heap堆

* 底层容器——使用vector进行数据的存储
* 特性：
  * 左子节点 pos = now * 2 + 1
  * 右子节点 pos = now * 2 + 2
  * 父节点 pos = (now - 1) / 2
  * 最大堆：任何节点，其值必须大于其子节点
