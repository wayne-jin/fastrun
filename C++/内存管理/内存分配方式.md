# 内存分配方式

### 内存分配方式

C++中内存分为五个区，分别是栈（stack），堆（heap),自由存储区，全局/静态存储区(bss)，常量存储区

**栈**：在执行函数时，函数内局部变量的存储单元，函数参数都可以在栈上创建，函数执行结束时这些存储单元自动被释放，栈内存分配运算内置于处理器指令集中，效率高，但分配内存容量有限。
**堆**：那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete，如果程序员没有释放掉，程序结束后，操作系统会自动回收（内存泄漏不是系统无法回收那片内存，而是你自己的应用程序无法使用那片内存。操作系统本身就有管理内存的职责，在进程结束后，操作系统会自动回收内存的）
**自由存储区：**就是那些由malloc等分配的内存块，他和堆是十分相似的，不过他是用free来结束自己的生命的
引申出来的问题：
很多编译器中new/delete都是以melloc和/free为基础实现的，那么就会引申出一个问题，自由存储区和堆相同么？
答案：堆是操作系统维护的一块内存，而自由存储时c++中通过new和delete动态分配和释放对象的抽象概念，堆和自由存储区并不等价
**全局/静态存储区**
全局变量和静态变量被分配到同一块内存中，在以前的c语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区
**常量存储区**
这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改  


### 堆和栈的区别

```C++
void func() {
    int* p = new int[5];
}
```

在这条语句里，看到了new就想到分配了一块堆内存，而指针p分配了一块栈内存。这句话的意思是，在栈内存中存放了一个指向对内存的指针p

堆和栈的区别主要分为以下六点：

* **管理方式不同：**
  对于栈来说，是编译器自动管理的，不需要我们手动控制
  对于堆来说，释放工作由程序员控制，容易产生内存泄漏

* **空间大小：**
  一般在32位系统下，堆内存可以达到4g空间
  对于栈来说，一般是有一定的空间大小，vc下面栈的空间默认1M（可以通过编译器设置修改）

* **碎片问题：**
  对于堆来说，频繁的new/delete势必会造成内存空间不连续，从而造成大量碎片，使程序效率降低
  对于栈来说，不会存在这个问题，因为栈使先进后出的队列，他们一一对应，永远不可能由一个内存块从栈中间弹出，在他弹出之前，它上面的后进的栈内容已被弹出

* **生长方向：**
  对于堆来说，生长方向是向上的，也就是向着内存地址增加的方向
  对于栈来说，它的生长方向是向下的，是向着内存地址减小的方向增长

* **分配方式不同：**
  堆都是动态分配的
  栈有两种分配方式动态分配和静态分配，静态分配是编译器完成的，比如局部变量的分配，动态分配是由alloca完成的，栈的动态分配是由编译器进行释放，无需我们手动实现

* **分配效率：**

  栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。
  堆则是C/C++函数库提供的，他的机制很是复杂，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间，就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分配到足够大小的内存，然后进行返回，显然，堆的效率比栈要低的多  

虽然栈有众多好处，但是和堆比不是那么灵活，有时候分配大量的内存空间，还是堆好一些
