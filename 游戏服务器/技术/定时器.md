# 定时器

### 定时器设计

网络消息：client->server,server->db

定时消息：定时任务，连接检测，buff，12点任务  


定时器与网络消息息息相关，使用

```c++
epoll_wait(ep,ev,n_ev,timeout)
```

处理定时任务，epoll_wait的timeout传入的参数是ms



* 定时器实现的接口
  * add_timer添加
  * del_timer删除
  * expire_timer每次找最近发生的

* nginx和redis的定时器设计

  * nginx下定时器是红黑树实现的，因为nginx是反向代理，定时任务很多，需要管理很多连接

  * redis下定时器是无序单链表，定时任务很少    
    

 ### 定时器所用数据结构及其时间复杂度

|        | 添加    | 删除    | 查找最近节点 |
| ------ | ------- | ------- | ------------ |
| 红黑树 | o(logn) | o(logn) | o(logn)      |
| 最小堆 | o(logn) | o(n)    | o(1)         |

大量删除操作时使用红黑树

实际业务中使用最多的是最小堆



* 多线程的环境下，能否用红黑树和最小堆来实现定时器

  不建议，因为如果这样做的话需要对整个结构加锁，这样会使锁的粒度很大  
  



### 使用时间轮来创建定时器

时间轮->锁的粒度小，可以多线程同时操作

## 多级时间轮

处理由简单的定时轮方法引起的存储器问题的另一种方式是在层次结构中使用多个定时轮，由多个层级来进行多次 hash

> 说明：
> 多级
> 子轮转动一圈，父轮转动一格
> 从父向子前进，无子过期
> 当前时间轮 slot num 为 cs，所有下级 slot 的总值为 ps ,插入slot key 为 k,任务绝对时间戳为 t 则 k = t / ps % cs

- 启动定时器： 直接 hash 到链表后面 push ，时间复杂度 O(1)
- 终止定时器： 直接 hash 到链表中删除节点，时间复杂度 O(1)
- 周期清算: 执行 hash 到的列表的周期清算，平均来看，时间复杂度认为是 O(1)

### 举例

我们来建立一个1天的定时器，时间轮分为3个，小时轮(24 slot)、分钟轮(60 slot)、秒轮(60 slot) 方便理解

> 时间周期：1s，过期判断：无子轮移动

创建的时间轮如下，看起来很想我们的手表，秒针转一起，分针转一格，分针转一圈，小时转一格

![img](https://pic2.zhimg.com/80/v2-26dd61defe2536a44719f08a49d1b51d_720w.jpg)

插入一个任务「03:59:04」,从最上方的轮子开始插入，先插入到小时轮中的k = 3的 slot 中

![img](https://pic2.zhimg.com/80/v2-bd872b2ba0f5e9448062445aca2f11b9_720w.jpg)

时间轮小时轮轮转到「3」slot 时，任务「03:59:04」从小时轮向子轮移动，插入到分钟轮的 k = 59的 slot 中

![img](https://pic2.zhimg.com/80/v2-15e5936d7b4649ed41544b266ecae991_720w.jpg)

当分钟轮移动到「59」slot 时，任务「03:59:04」从分钟轮向子轮移动，插入秒轮的 k = 4 的 slot 中

![img](https://pic2.zhimg.com/80/v2-b06251d903d2f8c696672c2e58cb20dd_720w.jpg)

当秒轮移动到「4」slot 时，任务「03:59:04」无子轮可移动，则认为过期

![img](https://pic3.zhimg.com/80/v2-078c74c685480e212a0720e843378332_720w.jpg)
