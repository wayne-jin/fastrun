# AOI

**AOI**（Area Of Interest）翻译过来就是“感兴趣的区域”，在MMORPG游戏中，玩家走到某个场景的坐标（x，y）处，就需要通过AOI来获取到当前坐标处，一定范围内的所有玩家以及NPC、怪物（其实也算NPC的一种）的相关位置信息，交由客户端生成对应的模型渲染并且进行其之间的交互。
当玩家进行移动时，同时也会对玩家范围内的玩家进行广播位置同步，使得其他玩家知晓当前玩家进行的移动位置和移动范围

当玩家进入一个游戏场景（地图、副本等）时，玩家所看到的各种各样的Entity（玩家，NPC，怪物皆算做Entity），都是通过服务器端的AOI系统在进行处理。显然,AOI实现算法的好坏，直接影响了当前游戏场景内所有玩家的游戏体验以及人数上限，如果AOI算法选择不好，那么可能会导致玩家在场景之中的一些游戏玩法产生不良效果，因此，选择一个优秀的AOI实现算法，是制作AOI系统的首要任务

MMO类型的游戏都会有野外和主城场景，一般来说，服务器只会同步你周边多少半径以内的玩家给你，太远的一是玩家屏幕看不到没有意义，二是同步太多的玩家对于服务器压力成倍数上涨

那么为了降低这部分的服务器性能，就需要降低服务器同步的量级，一种解决方案就是AOI。核心概念就是只对那些感兴趣的观察者发送数据。基于上面的例子而言，如果我们能把这个区域细分为10个，假定平均分配的情况下，每个区域里则只有10个人。那么此时每个人移动的时候，他就只要同步给同区域的10个人，大大减少需要同步的次数。同时，如果我们能充分利用现代CPU的核数，使用多线程来处理，则这个部分的性能损耗会大大的降低

但这个方案同时也会带来额外的问题，比如a这个人，之前在A区域，现在移动到了B区域，那么就需要一个管理器来协调A和B两个AOI区域的数据更新。虽然区域划分的越多，需要同步的次数越少，但是同样的，管理的复杂度就越高。所以，AOI需要根据实际的游戏场景做到一个合理的平衡  




### 常见的AOI算法

* **暴力法**

  所谓暴力法，就是不使用任何算法以及数据结构进行管理和组织，当玩家需要某个坐标点以及对应范围内的玩家列表时，暴力检索整个场景中的所有存在对象，然后进行坐标判断，随后返回给调用方的一种AOI实现算法，其检索的时间复杂度为*O(n)*,该算法的优缺点如下：

  **优点**

  * 实现简单，不需要多余的复杂数据结构，每个场景保存一个数组作为存储玩家对象列表的数据结构即可
  * 在少量Entity的地图场景之中（如小队副本，团队副本等），效率很高，且无需要复杂的数据结构

  **缺点**

  - 当场景中Entity数据量巨大，遍历整个数组会有很大的性能损耗
  - Entity的场景进入、场景退出等相关操作需要频繁的操纵数组，数组本身对这种随机性的插入与删除的性能支持不佳
  - 每次搜索单一Entity时，需要遍历整个数组  
    

  **总结**

  暴力法的实现简单， 无需多余复杂数据结构，并且在少量Entity的场景中有着优秀的性能体现（这个有些歧义，因为相对于后续的某些*O(logn)*时间复杂度的算法来讲，*O(n)*的确不算优秀，但是综合时间复杂度和实现难度来讲，的确算一个性能平衡的算法），比如说LOL、王者荣耀等Moba游戏来说，双方队伍里仅有10名玩家，整个场景内的Entity不会过多，此时，暴力法的综合表现可能是比较好的  
  

* **灯塔法**

  灯塔算法就是是把整个场景通过不同的粒度，利用网格划分成一个一个的大小相等的小区域， 在每个区域里树立灯塔。在Entity进入或退出格子时，维护每个灯塔上的Entity列表。灯塔好在哪？假设我们想知道某点周围10格内有哪些Entity，在没有灯塔的情况下，我们需要遍历所有的Entity计算其是否在范围内，随着地图内的Entity越来越多，查找的效率也会越来越差，所以我们需要一种方法来过滤那些明显不需要参与计算的Entity，所以我们将地图分割成一个个区域，在其中心放置一个假想的"灯塔"，每个"灯塔"都会保存区域内的Entity，这样当我们需要知道某点周围10格内有哪些Entity时，我们只需要计算出范围内有哪些"灯塔"，然后获取这些"灯塔"保存的Entity列表，针对这些Entity进行计算就能节省大量计算

  **优点**

  - 实现简单
  - 相较于暴力法，灯塔法将大量Entity分散到了多个灯塔中，对于每个灯塔还是 *O(n)*的复杂度，但由于把Entity数据量大量降了下来，所以性能要好的多

  **缺点**

  - 存储空间不仅和Entity数量有关，还和场景大小有关
  - 浪费内存
  - 且当场景规模大过对象数量规模时，性能还会下降。因为要遍历整个场景。对大地图不太合适  
    

  #### 总结

  灯塔法相较于暴力法进行了一些优化，使其场景内区分成不同的区域，每个区域的Entity数量就有了减少，也更快了，但是由于某些区域可能没有Entity存在，但是仍需要对其申请固定的内存，对内存有所浪费，且当场景规模大过对象数量规模时，性能还会下降。因为要遍历整个场景。对大地图不太合适   
  

  ### 十字链表算法

  十字链表算法是根据二维地图，将其分成x轴和y轴两个链表。如果是三维地图，则还需要维护多一个z轴的链表。将对象的坐标值按照大小相应的排列在相应的坐标轴上面。所谓十字链表，即把地图坐标轴中的 X 和 Y 轴看成是2个链表，将玩家的 X 坐标按照从小到大插入 X 链表，将玩家的 Y 坐标按照从小到大插入 Y 链表，查询时根据玩家的坐标分别从2个链表中取出范围内的所有玩家，对两个玩家列表做交集，即为我们需要发送消息的玩家列表

  **优点**

  - 节省内存空间，没有Entity那么就不会占用内存空间
  - 由于是有序链表，可以采用二分法进行快速搜索
  - 由于链表特性插入和删除不会那么麻烦

  **缺点**

  - 大数据量的搜索性能还是有待提高、但是可以通过跳表等进行优化

  

  
