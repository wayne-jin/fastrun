# 页面置换算法

**常见的页面置换算法**

当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：

#### 分类

**全局置换**：在整个内存空间置换

- 工作集算法
- 缺页率置换算法

**局部置换**：在本进程中进行置换

- 先进先出(FIFO)算法：

  - 思路：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。
  - 实现：按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。
  - 特点：实现简单；
  - 弊端：性能较差，调出的页面可能是经常访问的(无法体现页面冷热信息)

- 最不常用算法（ Least Frequently Used, LFU ）

  - 思路：缺页时，置换访问次数最少的页面

  - 实现：每个页面设置一个访问计数，访问页面时，访问计数加1，缺页时，置换计数最小的页面

  - 特点：算法开销大(排序)，开始时频繁使用，但以后不使用的页面很难置换(缓存颠簸)

    [![image](https://camo.githubusercontent.com/a84abe6586455d998e9012864fe2da2908f049d70ff287c66f4263c2f8bf74fa/68747470733a2f2f75706c6f616466696c65732e6e6f77636f6465722e636f6d2f696d616765732f32303139303331332f3331313433365f313535323437303437363638335f3930393834334345333236464437323433413235324530394338303737324238)](https://camo.githubusercontent.com/a84abe6586455d998e9012864fe2da2908f049d70ff287c66f4263c2f8bf74fa/68747470733a2f2f75706c6f616466696c65732e6e6f77636f6465722e636f6d2f696d616765732f32303139303331332f3331313433365f313535323437303437363638335f3930393834334345333236464437323433413235324530394338303737324238)

- 最近最少使用（ LRU ）算法: 当前最常采用。

  - 思路： 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。
  - 实现：缺页时，计算内存中每个逻辑页面的上一次访问时间，选择上一次使用到当前时间最长的页面.使用一个栈，新页面或者命中的页面则将该页面移动到栈底，每次替换栈顶的缓存页面。
  - 特点：可能达到最优的效果，LRU算法对热点数据命中率是很高的。
  - 缺陷：
    - 维护这样的访问链表开销比较大。
    - 缓存颠簸，当缓存（1，2，3）满了，之后数据访问（0，3，2，1，0，3，2，1。。。）。
    - 缓存污染，突然大量偶发性的数据访问，会让内存中存放大量冷数据。

- LRU-K（LRU-2、LRU-3）

  思想：最久未使用K次淘汰算法。

  LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。

  相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。

  实现：

  1）数据第一次被访问，加入到访问历史列表；

  2）如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；

  3）当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；

  4）缓存数据队列中被再次访问后，重新排序；

  5）需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。

  针对问题：

  LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。

- 2Q

  类似LRU-2。使用一个FIFO队列和一个LRU队列。

  实现：

  1）新访问的数据插入到FIFO队列；

  2）如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；

  3）如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；

  4）如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；

  5）LRU队列淘汰末尾的数据。

  针对问题：LRU的缓存污染

  弊端：

  当FIFO容量为2时，访问负载是：ABCABCABC会退化为FIFO，用不到LRU。
