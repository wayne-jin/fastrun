# 进程的状态，切换，调度

### 进程的状态与状态转换

#### 请你说一说进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞

* **进程的五种基本状态**：

   [![image](https://camo.githubusercontent.com/15ea54e6649d6fd3ef943ccfe67009d4beadcc21c62b021c3aec54df14891155/68747470733a2f2f75706c6f616466696c65732e6e6f77636f6465722e636f6d2f696d616765732f32303139303331332f3331313433365f313535323437303637383739345f4639424631313642443937413935413545363535444639453136373231383646)](https://camo.githubusercontent.com/15ea54e6649d6fd3ef943ccfe67009d4beadcc21c62b021c3aec54df14891155/68747470733a2f2f75706c6f616466696c65732e6e6f77636f6465722e636f6d2f696d616765732f32303139303331332f3331313433365f313535323437303637383739345f4639424631313642443937413935413545363535444639453136373231383646) 

  * 创建状态：进程正在被创建
  * 就绪状态：进程被加入到就绪队列中等待CPU调度运行
  * 执行状态：进程正在被运行
  * 等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行
  * 终止状态：进程运行完毕  
    

* **交换技术**

  当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I/O速度比处理机速度慢得多，可能出现全部进程阻塞等待I/O。

  针对以上问题，提出了两种解决方法：

  * 交换技术：换出一部分进程到外存，腾出内存空间
  * 虚拟存储技术：每个进程只能装入一部分程序和数据

  在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存

  从而出现了进程的挂起状态：进程被交换到外存，进程状态就成为了挂起状态  
  

* **活动阻塞，静止阻塞，活动就绪，静止就绪**

  * 活动阻塞：进程在内存，但是由于某种原因被阻塞了

  * 静止阻塞：进程在外存，同时被某种原因阻塞了

  * 活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行

  * 静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行

    从而出现了

  活动就绪 —— 静止就绪 （内存不够，调到外存）

  活动阻塞 —— 静止阻塞 （内存不够，调到外存）

  执行 —— 静止就绪 （时间片用完）

  进程在运行时有三种基本状态：**就绪态、运行态和阻塞态**

  * 运行（running）态：进程占有处理器正在运行的状态。进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态
  * 就绪（ready）态：进程具备运行条件，等待系统分配处理器以便运行的状态。 当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列
  * 阻塞（wait）态：又称等待态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态  
    

  

* **各状态之间的转换**：

  * 就绪→执行 处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态
  * 执行→就绪 处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态
  * 执行→阻塞 正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态
  * 阻塞→就绪 处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态  
    

### 进程调度



**进程调度时机**

* 当前运行的进程运行结束
* 当前运行的进程由于某种原因阻塞
* 执行完系统调用等系统程序后返回用户进程
* 在使用抢占调度的系统中，具有更高优先级的进程就绪时
* 分时系统中，分给当前进程的时间片用完  
  

**进程调度算法**

调度算法是指：根据系统的资源分配策略所规定的资源分配算法

* **先来先服务调度算法**

  先来先服务调度算法是一种最简单的调度算法，也称为先进先出或严格排队方案。当每个进程就绪后，它加入就绪队列。当前正运行的进程停止执行，选择在就绪队列中存在时间最长的进程运行。该算法既可以用于作业调度，也可以用于进程调度。先来先去服务比较适合于长作业（进程），而不利于短作业（进程）。在进程调度中，FCFS调度算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到完成或因某种原因而阻塞时才释放处理机

* **时间片轮转调度算法**

  时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。

* **短作业(SJF)优先调度算法**

  短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。短作业优先(SJF)调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。

* **最短剩余时间优先**

  最短剩余时间是针对最短进程优先增加了抢占机制的版本。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。

